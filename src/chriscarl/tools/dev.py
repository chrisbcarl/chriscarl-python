#!/usr/bin/env python
# -*- coding: utf-8 -*-
'''
Author:         Chris Carl
Email:          chrisbcarl@chriscarl.com
Date:           2024-11-22
Description:

Tool that is used to do lots of "dev" related things like git pushing, versioning, publishing, templating, conforming, etc.

Updates:
    2024-11-26 - tools.dev - moved code away from here and into tools.lib.dev
                 tools.dev - added the audit mode and "hardcoded" it a bit more
    2024-11-25 - tools.dev - this thing is practically a work of art (lol its late). create/run both work and do it well.
                 tools.dev - added --tool generation, logging reports the fullpath which is so much more satisfying
                 tools.dev - FIX: reruns when not in --force mode had a logic bug which caused tests to be dumped in the wrong place
                 tools.dev - added --no-test and dev create supports a list of modules
    2024-11-22 - tools.dev - initial commit

# TODO: add git commit shit
# TODO: add life cycle shit
# TODO: track which files were generated by this tool and which arent
# TODO: create an auditor that can scan and see who is out of spec wrt relpath, description, tests, what files dont have a counterpart, which do not import correclty, everyone imports instantly, etc.
'''

# stdlib imports
from __future__ import absolute_import, print_function, division, with_statement  # , unicode_literals
import os
import sys
import pydoc
import logging
from importlib import metadata
from dataclasses import dataclass, field
from typing import List, Optional, Dict, Type, Callable
from argparse import _SubParsersAction, ArgumentParser, ArgumentError, Namespace

# third party imports

# project imports
import chriscarl
from chriscarl.core.constants import REPO_DIRPATH, TESTS_DIRPATH, PYPA_SRC_DIRPATH
from chriscarl.core.lib.stdlib.logging import LOG_LEVELS
from chriscarl.core.lib.stdlib.argparse import ArgparseNiceFormat
from chriscarl.core.lib.stdlib.os import abspath
from chriscarl.core.lib.stdlib.json import read_json
from chriscarl.files import manifest
from chriscarl.tools.shed import dev

SCRIPT_RELPATH = 'chriscarl/tools/dev.py'
if not hasattr(sys, '_MEIPASS'):
    SCRIPT_FILEPATH = os.path.abspath(__file__)
else:
    SCRIPT_FILEPATH = os.path.abspath(os.path.join(sys._MEIPASS, SCRIPT_RELPATH))  # pylint: disable=no-member
SCRIPT_DIRPATH = os.path.dirname(SCRIPT_FILEPATH)
SCRIPT_NAME = os.path.splitext(os.path.basename(__file__))[0]
THIS_MODULE = sys.modules[__name__]
LOGGER = logging.getLogger(__name__)
LOGGER.addHandler(logging.NullHandler())

# argument defaults
DEFAULT_ROOT_LIB = chriscarl.__name__
DEFAULT_METADATA = metadata.metadata(DEFAULT_ROOT_LIB)
DEFAULT_AUTHOR = DEFAULT_METADATA.json['author']
DEFAULT_EMAIL = DEFAULT_METADATA.json['author_email']
DEFAULT_TESTS_DIRNAME = os.path.basename(TESTS_DIRPATH)


@dataclass
class Mode:
    '''
    Generic mode class, its got what everyone has in common.
    '''
    mode: str
    cwd: str
    module: str
    author: str
    email: str
    log_level: str

    @classmethod
    def main(cls):
        parser = cls.argparser()
        mode = cls.from_parser(parser)
        logging.basicConfig(format='%(asctime)s - %(levelname)10s - %(filename)s - %(funcName)s - %(message)s', level=mode.log_level)
        sys.exit(mode.run())

    @staticmethod
    def add_common_arguments(parser):
        # type: (ArgumentParser) -> ArgumentParser
        parser.add_argument('--cwd', type=str, default=os.getcwd(), help='cd to this directory')
        parser.add_argument('--module', type=str, default=DEFAULT_ROOT_LIB, help='change the default lib? all modes act on this "root".')
        parser.add_argument('--author', type=str, default=DEFAULT_AUTHOR, help='author first last no space')
        parser.add_argument('--email', type=str, default=DEFAULT_EMAIL, help='author email')
        parser.add_argument('--log-level', type=str, default='INFO', choices=LOG_LEVELS, help='log level?')
        return parser

    @classmethod
    def from_parser(cls, parser):
        # type: (ArgumentParser) -> Mode
        ns = parser.parse_args()
        return cls(**vars(ns))

    @classmethod
    def argparser(cls, subparser_root=None):
        # type: (Optional[_SubParsersAction[ArgumentParser]]) -> ArgumentParser
        if not subparser_root:
            mode = ArgumentParser(prog=SCRIPT_NAME, description=__doc__, formatter_class=ArgparseNiceFormat)
        else:
            mode = subparser_root.add_parser(cls.__name__.lower(), description=cls.__doc__, formatter_class=ArgparseNiceFormat)
        return mode

    def run(self):
        # type: () -> int
        LOGGER.info('%s running!', self.__class__.__name__)
        raise NotImplementedError()


@dataclass
class Create(Mode):
    '''
    Create is one of the CRUD modes allows you to "create" new modules.
    Based on predefined templates, it will create directories, __init__'s, module file, and test cases for you.

    Examples:
        - dev create lib.whatever
            # creates the following directory structure:
                - src/chriscarl/__init__.py
                - src/chriscarl/lib/__init__.py
                - src/chriscarl/lib/whatever.py
                - tests/chriscarl/test_lib.py
                - tests/chriscarl/lib/test_whatever.py
        - dev create lib
            # given you ran the above already which assumes certain things, creates the following directory structure:
                - SKIP: src/chriscarl/__init__.py
                - SKIP: src/chriscarl/lib/__init__.py
                - SKIP: src/chriscarl/lib/whatever.py
                - SKIP: tests/chriscarl/lib/test_whatever.py
        - dev create tools.fib --tool
            # generate a tool with the following files
                - SKIP: src/chriscarl/__init__.py
                - src/chriscarl/tools/__init__.py
                - src/chriscarl/tools.fib.py
                - tests/chriscarl/test_tools.py
                - tests/chriscarl/tools/test_fib.py
    '''
    modules: List[str] = field(default_factory=lambda: [])
    tests_dirname: str = DEFAULT_TESTS_DIRNAME
    force: bool = False
    tool: bool = False
    no_test: bool = False
    no_module: bool = False

    @classmethod
    def argparser(cls, subparser_root=None):
        # type: (Optional[_SubParsersAction[ArgumentParser]]) -> ArgumentParser
        mode = super().argparser(subparser_root=subparser_root)

        mode.add_argument('modules', type=str, nargs='+', default=[], help='space-separated, dot-separated module names, ex) "core.lib.stdlib.os" "core.lib.stdlib.sys"')
        mode.add_argument('--tests-dirname', type=str, default=DEFAULT_TESTS_DIRNAME, help='where should the tests go? core.lib will get a tests/module/core/test_lib.py')
        mode.add_argument('--force', '-f', action='store_true', help='overwrite file if exists?')
        mode.add_argument('--tool', '-t', action='store_true', help='make a tool out of this rather than a module (it still gets tests)')
        mode.add_argument('--no-test', '-n', action='store_true', help='do not generate the test')
        mode.add_argument('--no-module', action='store_true', help='do not generate the modules')
        Mode.add_common_arguments(mode)

        return mode

    def run(self):
        # type: () -> int
        _, filepaths = dev.create_modules_and_tests(
            self.module,
            self.modules,
            descriptions=read_json(manifest.FILEPATH_DEFAULT_DESCRIPTIONS_JSON),
            author=self.author,
            email=self.email,
            tests_dirname=self.tests_dirname,
            force=self.force,
            tool=self.tool,
            no_test=self.no_test,
            no_module=self.no_module,
        )
        return len(filepaths) > 0


@dataclass
class Read(Mode):
    pass


@dataclass
class Update(Mode):
    pass


@dataclass
class Delete(Mode):
    pass


@dataclass
class Run(Mode):
    '''
    Run is an expansion on CRUD, since CRUD is state-less, "Run" adds state.
    Basically "run" any number of functions arbitrarily.

    Examples:
        - dev run --funcs "files._self_modify" "files._self_verify"
            # runs the following code in the default root module
                - chriscarl.files._self_modify()
                - chriscarl.files._self_verify()
        - dev run --funcs "vars" "locals" "globals" --module "builtins"
            # runs the following code from a different module
                - builtins.vars()
                - builtins.locals()
                - builtins.globals()
    '''
    print_help: bool
    funcs: List[str] = field(default_factory=lambda: [])

    @classmethod
    def argparser(cls, subparser_root=None):
        # type: (Optional[_SubParsersAction[ArgumentParser]]) -> ArgumentParser
        mode = super().argparser(subparser_root=subparser_root)

        mode.add_argument('funcs', type=str, nargs='+', default=[], help='module.func_name where full will be <--module>.module.func_name, provide multiple to run in series')
        mode.add_argument('--print-help', action='store_true', help='print the help of those funcs rather than execute them')
        Mode.add_common_arguments(mode)

        return mode

    def run(self):
        # type: () -> int
        return dev.run_functions_by_dot_path(self.module, self.funcs, print_help=self.print_help, log_level=self.log_level)


@dataclass
class Audit(Mode):
    '''
    Audit is the way i literally audit my own code from an infrastructure perspective. it's a poor-mans' linter so to speak. It is an expansion on CRUD, since CRUD is state-less, "Audit" adds state.
    Things like relpath compliance, word replacing, swear jar, self-modification, etc.

    Examples:
        - dev audit relpath
        - dev audit manifest-modify
    '''
    func: Callable
    dirpath: str
    dry: bool
    included_dirs: List[str] = field(default_factory=lambda: [PYPA_SRC_DIRPATH, TESTS_DIRPATH])
    tests_dirname: str = DEFAULT_TESTS_DIRNAME

    @classmethod
    def argparser(cls, subparser_root=None):
        # type: (Optional[_SubParsersAction[ArgumentParser]]) -> ArgumentParser
        mode = super().argparser(subparser_root=subparser_root)

        example_audit_func = 'tdd'
        funcs = mode.add_subparsers(
            help='which func do you want? run "{} {} {} -h" to get help on the {!r} func'.format(SCRIPT_NAME, cls.__name__.lower(), example_audit_func, example_audit_func)
        )

        manifest_modify = funcs.add_parser('manifest-modify', usage=pydoc.render_doc(dev.audit_manifest_modify))
        manifest_modify.set_defaults(func=dev.audit_manifest_modify)
        Audit.add_common_arguments(manifest_modify)

        manifest_verify = funcs.add_parser('manifest-verify', usage=pydoc.render_doc(dev.audit_manifest_verify))
        manifest_verify.set_defaults(func=dev.audit_manifest_verify)
        Audit.add_common_arguments(manifest_verify)

        relpath = funcs.add_parser('relpath', usage=pydoc.render_doc(dev.audit_relpath))
        relpath.set_defaults(func=dev.audit_relpath)
        Audit.add_common_arguments(relpath)

        tdd = funcs.add_parser('tdd', usage=pydoc.render_doc(dev.audit_tdd))
        tdd.set_defaults(func=dev.audit_tdd)
        Audit.add_common_arguments(tdd)

        return mode

    @staticmethod
    def add_common_arguments(parser):
        Mode.add_common_arguments(parser)
        parser.add_argument('--dirpath', type=str, default=REPO_DIRPATH, help='where do we start crawling?')
        parser.add_argument(
            '--included_dirs', type=str, nargs='+', default=[PYPA_SRC_DIRPATH, TESTS_DIRPATH], help='any directories that you do care about, and run them relatively to dirpath?'
        )
        parser.add_argument('--dry', action='store_true', help='do not write?')
        parser.add_argument('--tests-dirname', type=str, default=DEFAULT_TESTS_DIRNAME, help='name of the tests folder?')

    def run(self):
        # type: () -> int
        if self.func is dev.audit_relpath:
            return dev.audit_relpath(dirpath=self.dirpath, included_dirs=self.included_dirs, dry=self.dry)
        elif self.func is dev.audit_tdd:
            return dev.audit_tdd(
                dirpath=self.dirpath,
                module_name=self.module,
                tests_dirname=self.tests_dirname,
                dry=self.dry,
                descriptions=read_json(manifest.FILEPATH_DEFAULT_DESCRIPTIONS_JSON),
                author=self.author,
                email=self.email,
                force=False,
                tool=False,
                no_test=False,
                no_module=True,
            )
        else:
            return self.func()


MODE_MAP: Dict[str, Type[Mode]] = {
    'create': Create,
    'read': Read,
    'update': Update,
    'delete': Delete,
    'run': Run,
    'audit': Audit,
}


def main():
    # type: () -> int
    try:
        parser = ArgumentParser(prog=SCRIPT_NAME, description=__doc__, formatter_class=ArgparseNiceFormat)

        example_mode = list(MODE_MAP)[0]
        modes = parser.add_subparsers(help='which mode do you want? run "{} {} -h" to get help on the {!r} mode'.format(SCRIPT_NAME, example_mode, example_mode))

        for mode_name, Class in MODE_MAP.items():
            mode_parser = Class.argparser(subparser_root=modes)  # type: ignore
            mode_parser.set_defaults(mode=mode_name)
        subparser = [action for action in parser._actions if isinstance(action, _SubParsersAction)][0]
        ns = parser.parse_args()
    except ArgumentError as ae:
        print('ERROR:', ae, file=sys.stderr)
        sys.exit(1)

    if not hasattr(ns, 'mode'):
        raise ArgumentError(subparser, 'you have to provide an mode')

    Class = MODE_MAP[ns.mode]
    mode = Class.from_parser(parser)

    logging.basicConfig(format='%(asctime)s - %(levelname)10s - %(filename)s - %(funcName)s - %(message)s', level=mode.log_level)
    LOGGER.debug(vars(mode))

    pwd = os.getcwd()
    try:
        if abspath(mode.cwd) != abspath(pwd):
            LOGGER.debug('changing directory to "%s" from "%s"', mode.cwd, pwd)
            os.chdir(mode.cwd)
        return mode.run()
    finally:
        if abspath(mode.cwd) != abspath(pwd):
            LOGGER.debug('changing directory back to "%s" from "%s"', pwd, mode.cwd)
            os.chdir(pwd)


if __name__ == '__main__':
    sys.exit(main())
