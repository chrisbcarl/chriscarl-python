#!/usr/bin/env python
# -*- coding: utf-8 -*-
'''
Author:         Chris Carl
Email:          chrisbcarl@chriscarl.com
Date:           2024-11-22
Description:

Tool that is used to do lots of "dev" related things like git pushing, versioning, publishing, templating, conforming, etc.

Updates:
    2024-11-25 - chriscarl.tools.dev - this thing is practically a work of art (lol its late). create/run both work and do it well.
    2024-11-22 - chriscarl.tools.dev - initial commit

# TODO: add git commit shit
# TODO: add life cycle shit
# TODO: redo the create with abs relpath rather than chdir relpath...
# TODO: track which files were generated by this tool and which arent
# TODO: create an auditor that can scan and see who is out of spec wrt relpath, description, tests, what files dont have a counterpart, which do not import correclty, everyone imports instantly, etc.
'''

# stdlib imports
from __future__ import absolute_import, print_function, division, with_statement  # , unicode_literals
import os
import sys
import logging
import importlib
from importlib import metadata
from dataclasses import dataclass
from typing import List, Optional
from argparse import _SubParsersAction, ArgumentParser, ArgumentError

# third party imports

# project imports
import chriscarl
from chriscarl.core.constants import DATE, TESTS_DIRPATH
from chriscarl.core.functors.misc import LOG_LEVELS, ArgparseNiceFormat
from chriscarl.core.functors.python import run_func_args_kwargs
from chriscarl.core.lib.stdlib.io import read_text_file, write_text_file
from chriscarl.core.lib.stdlib.json import read_json
import chriscarl.files
from chriscarl.files import (
    FILEPATH_DEFAULT_DESCRIPTIONS_JSON,
    FILEPATH_TEMPLATE,
    FILEPATH_MOD_LIB_TEMPLATE,
    FILEPATH_TEST_TEMPLATE,
    FILEPATH_TOOL_TEMPLATE,
)

SCRIPT_RELPATH = 'chriscarl/libraries/third/parameterized.py'
if not hasattr(sys, '_MEIPASS'):
    SCRIPT_FILEPATH = os.path.abspath(__file__)
else:
    SCRIPT_FILEPATH = os.path.abspath(os.path.join(sys._MEIPASS, SCRIPT_RELPATH))  # pylint: disable=no-member
SCRIPT_DIRPATH = os.path.dirname(SCRIPT_FILEPATH)
SCRIPT_NAME = os.path.splitext(os.path.basename(__file__))[0]
THIS_MODULE = sys.modules[__name__]
LOGGER = logging.getLogger(__name__)
LOGGER.addHandler(logging.NullHandler())

# argument defaults
MODES = ['create', 'read', 'update', 'delete', 'new', 'run']
DEFAULT_ROOT_LIB = chriscarl.__name__
DEFAULT_METADATA = metadata.metadata(DEFAULT_ROOT_LIB)
DEFAULT_AUTHOR = DEFAULT_METADATA.json['author']
DEFAULT_EMAIL = DEFAULT_METADATA.json['author_email']


@dataclass
class Mode:
    '''
    Generic mode class, its got what everyone has in common.
    '''
    cwd: str
    operation: str
    root_module: str
    author: str
    email: str
    log_level: str

    @staticmethod
    def add_common_arguments(parser):
        # type: (ArgumentParser) -> ArgumentParser
        parser.add_argument('--cwd', type=str, default=os.getcwd(), help='cd to this directory')
        parser.add_argument('--root-module', type=str, default=DEFAULT_ROOT_LIB, help='change the default lib? all operations act on this "root".')
        parser.add_argument('--author', type=str, default=DEFAULT_AUTHOR, help='author first last no space')
        parser.add_argument('--email', type=str, default=DEFAULT_EMAIL, help='author email')
        parser.add_argument('--log-level', type=str, default='INFO', choices=LOG_LEVELS, help='log level?')
        return parser

    @classmethod
    def from_parser(cls, parser):
        # type: (ArgumentParser) -> Mode
        ns = parser.parse_args()
        return cls(**vars(ns))

    @classmethod
    def argparser(cls, subparser_root=None):
        # type: (Optional[_SubParsersAction[ArgumentParser]]) -> ArgumentParser
        if not subparser_root:
            mode = ArgumentParser(prog=SCRIPT_NAME, description=__doc__, formatter_class=ArgparseNiceFormat)
        else:
            mode = subparser_root.add_parser(cls.__name__.lower(), description=cls.__doc__, formatter_class=ArgparseNiceFormat)
        return mode

    def run(self):
        # type: () -> int
        logging.info('%s running!', self.__class__.__name__)
        raise NotImplementedError()


DEFAULT_DESCRIPTIONS = read_json(FILEPATH_DEFAULT_DESCRIPTIONS_JSON)


@dataclass
class Create(Mode):
    '''
    Create is one of the CRUD operations allows you to "create" new modules.
    Based on predefined templates, it will create folders, __init__'s, module file, and test cases for you.

    ex) dev create lib.whatever
        creates
            - src/chriscarl/__init__.py
            - src/chriscarl/lib/__init__.py
            - src/chriscarl/lib/whatever.py
            - tests/chriscarl/test_lib.py
            - tests/chriscarl/lib/test_whatever.py
    ex) dev create lib (given you ran the above already which assumes certain things)
        creates
            - SKIP: src/chriscarl/__init__.py
            - SKIP: src/chriscarl/lib/__init__.py
            - SKIP: src/chriscarl/lib/whatever.py
            - SKIP: tests/chriscarl/lib/test_whatever.py
    '''
    module: str
    tests_dirpath: str
    force: str

    @classmethod
    def argparser(cls, subparser_root=None):
        # type: (Optional[_SubParsersAction[ArgumentParser]]) -> ArgumentParser
        mode = super().argparser(subparser_root=subparser_root)

        mode.add_argument('module', type=str, help='dot separated module name, ex core.lib.stdlib.sys')
        mode.add_argument('--tests-dirpath', type=str, default=TESTS_DIRPATH, help='where should the tests go? core.lib will get a tests/module/core/test_lib.py')
        mode.add_argument('--force', '-f', action='store_true', help='overwrite file if exists?')
        Mode.add_common_arguments(mode)

        return mode

    def run(self):
        # type: () -> int
        cwd = os.getcwd()
        warnings = 0
        if self.module.startswith(self.root_module):
            raise ValueError('you provided root module {} and module {}, you dont need the root in the 2nd.'.format(self.root_module, self.module))

        try:
            tokens = self.module.split('.')
            module_template = read_text_file(FILEPATH_TEMPLATE)
            test_template = read_text_file(FILEPATH_TEST_TEMPLATE)

            logging.info('inspecting ./src or ./src/%s convention', self.root_module)
            if os.path.isdir('src'):
                os.chdir('src')
                if not os.path.isdir(self.root_module):
                    raise OSError('did not detect ./src/{} directory despite ./src exists! fix this!'.format(self.root_module))
            else:
                if not os.path.isdir(self.root_module):
                    raise OSError('did not detect ./src/{} or ./{} directory! fix this and use either or convention!'.format(self.root_module, self.root_module))
            script_filename = '{}.py'.format(tokens[-1])
            script_filepath = '/'.join([self.root_module, *tokens[:-1], script_filename])
            os.chdir(self.root_module)

            for t, token in enumerate(tokens[:-1]):
                # create folders
                logging.info('step 1 - directory at %r!', token)
                if os.path.isfile('{}.py'.format(token)):
                    logging.warning('step 1 - directory at %r already exists!', token)
                    if self.force:
                        logging.critical('step 1 - directory at %r already exists! FORCING!', token)
                    else:
                        warnings += 1
                        continue
                if not os.path.isdir(token):
                    os.makedirs(token)

                # create inits
                logging.info('step 2 - __init__.py at %r', token)
                os.chdir(token)
                if os.path.isfile('__init__.py'):
                    logging.warning('step 2 - __init__.py at %r already exists!', token)
                    if self.force:
                        logging.critical('step 2 - __init__.py at %r already exists! FORCING!', token)
                    else:
                        warnings += 1
                        continue
                write_text_file('__init__.py', '')

            # create module file
            logging.info('step 3 - module - %d / %d: %r', t, len(tokens) - 1, token)
            doit = True
            if os.path.isfile(script_filename):
                logging.warning('step 3 - module exists!')
                if self.force:
                    logging.critical('step 3 - module exists! FORCING!')
                else:
                    doit = False
                    warnings += 1

            if doit:
                description_key_length = -1
                default_description = ''
                for k, v in DEFAULT_DESCRIPTIONS.items():
                    if k in self.module and len(k) > description_key_length:
                        description_key_length = len(k)
                        default_description = '{} are modules that {}'.format(k, v)

                content = module_template.format(
                    author=self.author,
                    email=self.email,
                    date=DATE,
                    module_dot_path=self.module,
                    default_description=default_description,
                    script_relpath=script_filepath,
                )
                write_text_file(script_filename, content)

            # create test case
            logging.info('step 4 - tests')
            os.chdir(cwd)
            if not os.path.isdir(self.tests_dirpath):
                os.makedirs(self.tests_dirpath)
            os.chdir(self.tests_dirpath)
            tests_base = os.path.basename(self.tests_dirpath)
            tokens = [self.root_module] + tokens
            for t, token in enumerate(tokens):
                module_so_far = '.'.join(tokens[:t + 1])
                test_filename = 'test_{}.py'.format(token)
                logging.info('step 4 - %r!', test_filename)
                if os.path.isfile(test_filename):
                    logging.warning('step 4 - %r already exists!', test_filename)
                    if self.force:
                        logging.critical('step 4 - %r already exists! FORCING!', test_filename)
                    else:
                        warnings += 1
                        continue
                test_module_dot_path = '{}.{}'.format(tests_base, module_so_far)
                test_relpath = '/'.join([tests_base, *tokens[:t], test_filename])
                content = test_template.format(
                    author=self.author,
                    email=self.email,
                    date=DATE,
                    module_dot_path=module_so_far,
                    test_module_dot_path=test_module_dot_path,
                    script_relpath=test_relpath,
                )
                write_text_file(test_filename, content)
                if t == len(tokens) - 1:
                    break
                if not os.path.isdir(token):
                    os.makedirs(token)
                os.chdir(token)

            return warnings
        finally:
            os.chdir(cwd)


@dataclass
class Read(Mode):
    pass


@dataclass
class Update(Mode):
    pass


@dataclass
class Delete(Mode):
    pass


@dataclass
class New(Mode):
    pass


SUB_OPERATIONS = [
    'files._self_modify',
    'files._self_verify',
]


@dataclass
class Run(Mode):
    '''
    Run is an expansion on CRUD, since CRUD is state-less, "Run" adds state.
    NOTE: this only really works in the context of the chriscarl library...
    Basically "run" any number of micro-operations--things like linting, word replacing, swear jar, etc.
    '''
    operation_help: str
    operations: List[str]

    @classmethod
    def argparser(cls, subparser_root=None):
        # type: (Optional[_SubParsersAction[ArgumentParser]]) -> ArgumentParser
        mode = super().argparser(subparser_root=subparser_root)

        muex = mode.add_mutually_exclusive_group(required=True)
        muex.add_argument(
            '--operations', type=str, nargs='+', default=[], help='module.func_name where full will be <--root-module>.module.func_name, provide multiple to run in series'
        )
        muex.add_argument('--operation-help', type=str, help='print the help of a function rather than run it')
        Mode.add_common_arguments(mode)

        return mode

    def run(self):
        # type: () -> int
        try:
            if self.operation_help:
                full_name = '{}.{}'.format(self.root_module, self.operation_help)
                tokens = full_name.split('.')
                module = importlib.import_module('.'.join(tokens[:-1]))
                func = getattr(module, tokens[-1])
                help(func)
                return 0
            else:
                full_names = ['{}.{}'.format(self.root_module, operation) for operation in self.operations]
                funcs = []
                for full_name in full_names:
                    tokens = full_name.split('.')
                    module = importlib.import_module('.'.join(tokens[:-1]))
                    func = getattr(module, tokens[-1])
                    funcs.append(func)

            logging.info('running %d operations %s!', len(funcs), len(self.operations))
            results = list(run_func_args_kwargs(funcs, log_level=self.log_level))
            return 0 if all(results) else 1
        except ModuleNotFoundError as mnfe:
            print('ERROR: could not find module {!r} based on provided root {!r} and operations!'.format(mnfe.name, self.root_module))
            return 1
        except AttributeError as ae:
            print('ERROR: {}, perhaps a mispelled or stale function name {!r}?'.format(' '.join(ae.args), ae.name))
            return 1


class App:
    '''
    App definiton, most logic goes here
    '''

    @staticmethod
    def from_parser(parser):
        # type: (ArgumentParser) -> Mode
        subparser = [action for action in parser._actions if isinstance(action, _SubParsersAction)][0]
        ns = parser.parse_args()
        if not hasattr(ns, 'operation'):
            raise ArgumentError(subparser, 'you have to provide an operation')
        if ns.operation == 'create':
            return Create(**vars(ns))
        elif ns.operation == 'run':
            return Run(**vars(ns))
        raise NotImplementedError('not yet implemented {}!'.format(ns.operation))

    @classmethod
    def argparser(cls, subparser_root=None):
        # type: (Optional[_SubParsersAction[ArgumentParser]]) -> ArgumentParser
        parser = ArgumentParser(prog=SCRIPT_NAME, description=__doc__, formatter_class=ArgparseNiceFormat)

        operations = parser.add_subparsers(help='which operation do you want? run "{} {} -h" to get help on the {!r} operation'.format(SCRIPT_NAME, MODES[0], MODES[0]))

        glbls = globals()
        for mode_name in MODES:
            ModeClass = glbls[mode_name.capitalize()]
            mode = ModeClass.argparser(subparser_root=operations)
            mode.set_defaults(operation=mode_name)

        return parser


def main():
    # type: () -> int
    try:
        parser = App.argparser()
        mode = App.from_parser(parser)
        logging.basicConfig(format='%(asctime)s - %(levelname)10s - %(filename)s - %(funcName)s - %(message)s', level=mode.log_level)
    except ArgumentError as ae:
        print('ERROR:', ae, file=sys.stderr)
        sys.exit(1)
    logging.debug(vars(mode))
    pwd = os.getcwd()
    try:
        os.chdir(mode.cwd)
        return mode.run()
    finally:
        os.chdir(pwd)


if __name__ == '__main__':
    sys.exit(main())
