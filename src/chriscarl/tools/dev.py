#!/usr/bin/env python
# -*- coding: utf-8 -*-
'''
Author:         Chris Carl
Email:          chrisbcarl@chriscarl.com
Date:           2024-11-22
Description:

Tool that is used to do lots of "dev" related things like git pushing, versioning, publishing, templating, conforming, etc.

Updates:
    2024-11-26 - tools.dev - moved code away from here and into tools.lib.dev
    2024-11-25 - tools.dev - this thing is practically a work of art (lol its late). create/run both work and do it well.
                 tools.dev - added --tool generation, logging reports the fullpath which is so much more satisfying
                 tools.dev - FIX: reruns when not in --force mode had a logic bug which caused tests to be dumped in the wrong place
                 tools.dev - added --no-test and dev create supports a list of modules
    2024-11-22 - tools.dev - initial commit

# TODO: add git commit shit
# TODO: add life cycle shit
# TODO: track which files were generated by this tool and which arent
# TODO: create an auditor that can scan and see who is out of spec wrt relpath, description, tests, what files dont have a counterpart, which do not import correclty, everyone imports instantly, etc.
'''

# stdlib imports
from __future__ import absolute_import, print_function, division, with_statement  # , unicode_literals
import os
import sys
import pydoc
import logging
import inspect
from importlib import metadata
from dataclasses import dataclass, field
from typing import List, Optional, Dict, Type, Callable, Tuple
from argparse import _SubParsersAction, ArgumentParser, ArgumentError

# third party imports

# project imports
import chriscarl
from chriscarl.core.constants import DATE, REPO_DIRPATH, TESTS_DIRPATH, PYPA_SRC_DIRPATH
from chriscarl.core.functors.misc import LOG_LEVELS, ArgparseNiceFormat
from chriscarl.core.functors.python import run_func_args_kwargs
from chriscarl.core.lib.stdlib.io import read_text_file, write_text_file
from chriscarl.core.lib.stdlib.os import make_dirpath, abspath
from chriscarl.core.lib.stdlib.json import read_json
import chriscarl.files
from chriscarl.files.manifest import (
    FILEPATH_DEFAULT_DESCRIPTIONS_JSON,
    FILEPATH_TEMPLATE,
    FILEPATH_MOD_LIB_TEMPLATE,
    FILEPATH_TEST_TEMPLATE,
    FILEPATH_TOOL_TEMPLATE,
)
from chriscarl.tools.lib import dev

SCRIPT_RELPATH = 'chriscarl/tools/dev.py'
if not hasattr(sys, '_MEIPASS'):
    SCRIPT_FILEPATH = os.path.abspath(__file__)
else:
    SCRIPT_FILEPATH = os.path.abspath(os.path.join(sys._MEIPASS, SCRIPT_RELPATH))  # pylint: disable=no-member
SCRIPT_DIRPATH = os.path.dirname(SCRIPT_FILEPATH)
SCRIPT_NAME = os.path.splitext(os.path.basename(__file__))[0]
THIS_MODULE = sys.modules[__name__]
LOGGER = logging.getLogger(__name__)
LOGGER.addHandler(logging.NullHandler())

# argument defaults
DEFAULT_ROOT_LIB = chriscarl.__name__
DEFAULT_METADATA = metadata.metadata(DEFAULT_ROOT_LIB)
DEFAULT_AUTHOR = DEFAULT_METADATA.json['author']
DEFAULT_EMAIL = DEFAULT_METADATA.json['author_email']


@dataclass
class Mode:
    '''
    Generic mode class, its got what everyone has in common.
    '''
    mode: str
    cwd: str
    module: str
    author: str
    email: str
    log_level: str

    @classmethod
    def main(cls):
        parser = cls.argparser()
        mode = cls.from_parser(parser)
        logging.basicConfig(format='%(asctime)s - %(levelname)10s - %(filename)s - %(funcName)s - %(message)s', level=mode.log_level)
        sys.exit(mode.run())

    @staticmethod
    def add_common_arguments(parser):
        # type: (ArgumentParser) -> ArgumentParser
        parser.add_argument('--cwd', type=str, default=os.getcwd(), help='cd to this directory')
        parser.add_argument('--module', type=str, default=DEFAULT_ROOT_LIB, help='change the default lib? all modes act on this "root".')
        parser.add_argument('--author', type=str, default=DEFAULT_AUTHOR, help='author first last no space')
        parser.add_argument('--email', type=str, default=DEFAULT_EMAIL, help='author email')
        parser.add_argument('--log-level', type=str, default='INFO', choices=LOG_LEVELS, help='log level?')
        return parser

    @classmethod
    def from_parser(cls, parser):
        # type: (ArgumentParser) -> Mode
        ns = parser.parse_args()
        return cls(**vars(ns))

    @classmethod
    def argparser(cls, subparser_root=None):
        # type: (Optional[_SubParsersAction[ArgumentParser]]) -> ArgumentParser
        if not subparser_root:
            mode = ArgumentParser(prog=SCRIPT_NAME, description=__doc__, formatter_class=ArgparseNiceFormat)
        else:
            mode = subparser_root.add_parser(cls.__name__.lower(), description=cls.__doc__, formatter_class=ArgparseNiceFormat)
        return mode

    def run(self):
        # type: () -> int
        LOGGER.info('%s running!', self.__class__.__name__)
        raise NotImplementedError()


DEFAULT_DESCRIPTIONS = read_json(FILEPATH_DEFAULT_DESCRIPTIONS_JSON)


@dataclass
class Create(Mode):
    '''
    Create is one of the CRUD modes allows you to "create" new modules.
    Based on predefined templates, it will create directories, __init__'s, module file, and test cases for you.

    Examples:
        1. dev create lib.whatever
            # creates the following directory structure:
                - src/chriscarl/__init__.py
                - src/chriscarl/lib/__init__.py
                - src/chriscarl/lib/whatever.py
                - tests/chriscarl/test_lib.py
                - tests/chriscarl/lib/test_whatever.py
        2. dev create lib
            # given you ran the above already which assumes certain things, creates the following directory structure:
                - SKIP: src/chriscarl/__init__.py
                - SKIP: src/chriscarl/lib/__init__.py
                - SKIP: src/chriscarl/lib/whatever.py
                - SKIP: tests/chriscarl/lib/test_whatever.py
        2. dev create tools.fib --tool
            # generate a tool with the following files
                - SKIP: src/chriscarl/__init__.py
                - src/chriscarl/tools/__init__.py
                - src/chriscarl/tools.fib.py
                - tests/chriscarl/test_tools.py
                - tests/chriscarl/tools/test_fib.py
    '''
    modules: List[str] = field(default_factory=lambda: [])
    tests_dirpath: str = TESTS_DIRPATH
    force: bool = False
    tool: bool = False
    no_test: bool = False

    @classmethod
    def argparser(cls, subparser_root=None):
        # type: (Optional[_SubParsersAction[ArgumentParser]]) -> ArgumentParser
        mode = super().argparser(subparser_root=subparser_root)

        mode.add_argument('modules', type=str, nargs='+', default=[], help='space-separated, dot-separated module names, ex) "core.lib.stdlib.os" "core.lib.stdlib.sys"')
        mode.add_argument('--tests-dirpath', type=str, default=TESTS_DIRPATH, help='where should the tests go? core.lib will get a tests/module/core/test_lib.py')
        mode.add_argument('--force', '-f', action='store_true', help='overwrite file if exists?')
        mode.add_argument('--tool', '-t', action='store_true', help='make a tool out of this rather than a module (it still gets tests)')
        mode.add_argument('--no-test', '-n', action='store_true', help='do not generate the test')
        Mode.add_common_arguments(mode)

        return mode

    def run(self):
        # type: () -> int
        return dev.create_modules_and_tests(
            self.module,
            self.modules,
            DEFAULT_DESCRIPTIONS,
            author=self.author,
            email=self.email,
            tests_dirpath=self.tests_dirpath,
            force=self.force,
            tool=self.tool,
            no_test=self.no_test
        )


@dataclass
class Read(Mode):
    pass


@dataclass
class Update(Mode):
    pass


@dataclass
class Delete(Mode):
    pass


@dataclass
class Run(Mode):
    '''
    Run is an expansion on CRUD, since CRUD is state-less, "Run" adds state.
    Basically "run" any number of functions arbitrarily.

    Examples:
        1. dev run --funcs "files._self_modify" "files._self_verify"
            # runs the following code in the default root module
                - chriscarl.files._self_modify()
                - chriscarl.files._self_verify()
        2. dev run --funcs "vars" "locals" "globals" --module "builtins"
            # runs the following code from a different module
                - builtins.vars()
                - builtins.locals()
                - builtins.globals()
    '''
    print_help: bool
    funcs: List[str] = field(default_factory=lambda: [])

    @classmethod
    def argparser(cls, subparser_root=None):
        # type: (Optional[_SubParsersAction[ArgumentParser]]) -> ArgumentParser
        mode = super().argparser(subparser_root=subparser_root)

        mode.add_argument('funcs', type=str, nargs='+', default=[], help='module.func_name where full will be <--module>.module.func_name, provide multiple to run in series')
        mode.add_argument('--print-help', action='store_true', help='print the help of those funcs rather than execute them')
        Mode.add_common_arguments(mode)

        return mode

    def run(self):
        # type: () -> int
        return dev.run_functions_by_dot_path(self.module, self.funcs, print_help=self.print_help, log_level=self.log_level)


AUDIT_FUNCS: Dict[str, Tuple[Callable, tuple, dict]] = {
    'manifest-modify': (dev.audit_manifest_modify, tuple(), {}),
    'manifest-verify': (dev.audit_manifest_verify, tuple(), {}),
    'relpath': (dev.audit_relpath, (), {
        'dirpath': REPO_DIRPATH,
        'included_dirs': [PYPA_SRC_DIRPATH, TESTS_DIRPATH],
        'force': True
    }),
}


@dataclass
class Audit(Mode):
    '''
    Audit is the way i literally audit my own code from an infrastructure perspective. it's a poor-mans' linter so to speak. It is an expansion on CRUD, since CRUD is state-less, "Audit" adds state.
    Things like relpath compliance, word replacing, swear jar, self-modification, etc.

    Examples:
        1. dev audit manifest_modify
        2. dev audit relpath
    '''
    func: Callable
    args: tuple
    kwargs: dict

    @classmethod
    def argparser(cls, subparser_root=None):
        # type: (Optional[_SubParsersAction[ArgumentParser]]) -> ArgumentParser
        mode = super().argparser(subparser_root=subparser_root)

        example_audit_func = list(AUDIT_FUNCS)[0]
        funcs = mode.add_subparsers(help='which func do you want? run "{} {} -h" to get help on the {!r} func'.format(SCRIPT_NAME, example_audit_func, example_audit_func))
        for k, v in AUDIT_FUNCS.items():
            func, args, kwargs = v
            audit_func_parser = funcs.add_parser(k, usage=pydoc.render_doc(func))
            audit_func_parser.set_defaults(func=func)
            audit_func_parser.set_defaults(args=args)
            audit_func_parser.set_defaults(kwargs=kwargs)
            Mode.add_common_arguments(audit_func_parser)

        return mode

    def run(self):
        # type: () -> int
        return self.func(*self.args, **self.kwargs)


MODE_MAP: Dict[str, Type[Mode]] = {
    'create': Create,
    'read': Read,
    'update': Update,
    'delete': Delete,
    'run': Run,
    'audit': Audit,
}


def main():
    # type: () -> int
    try:
        parser = ArgumentParser(prog=SCRIPT_NAME, description=__doc__, formatter_class=ArgparseNiceFormat)

        example_mode = list(MODE_MAP)[0]
        modes = parser.add_subparsers(help='which mode do you want? run "{} {} -h" to get help on the {!r} mode'.format(SCRIPT_NAME, example_mode, example_mode))

        for mode_name, Class in MODE_MAP.items():
            mode_parser = Class.argparser(subparser_root=modes)  # type: ignore
            mode_parser.set_defaults(mode=mode_name)
        subparser = [action for action in parser._actions if isinstance(action, _SubParsersAction)][0]
        ns = parser.parse_args()
    except ArgumentError as ae:
        print('ERROR:', ae, file=sys.stderr)
        sys.exit(1)

    if not hasattr(ns, 'mode'):
        raise ArgumentError(subparser, 'you have to provide an mode')

    Class = MODE_MAP[ns.mode]
    mode = Class(**(vars(ns)))

    logging.basicConfig(format='%(asctime)s - %(levelname)10s - %(filename)s - %(funcName)s - %(message)s', level=mode.log_level)
    LOGGER.debug(vars(mode))

    pwd = os.getcwd()
    try:
        if abspath(mode.cwd) != abspath(pwd):
            LOGGER.debug('changing directory to "%s" from "%s"', mode.cwd, pwd)
            os.chdir(mode.cwd)
        return mode.run()
    finally:
        if abspath(mode.cwd) != abspath(pwd):
            LOGGER.debug('changing directory back to "%s" from "%s"', pwd, mode.cwd)
            os.chdir(pwd)


if __name__ == '__main__':
    sys.exit(main())
