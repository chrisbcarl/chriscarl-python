#!/usr/bin/env python
# -*- coding: utf-8 -*-
'''
Author:         Chris Carl
Email:          chrisbcarl@chriscarl.com
Date:           2024-11-22
Description:

Tool that is used to do lots of "dev" related things like git pushing, versioning, publishing, templating, conforming, etc.

Updates:
    2024-11-29 - tools.dev - added stubs, clean, and test
    2024-11-26 - tools.dev - moved code away from here and into tools.lib.dev
                 tools.dev - added the audit mode and "hardcoded" it a bit more
    2024-11-25 - tools.dev - this thing is practically a work of art (lol its late). create/run both work and do it well.
                 tools.dev - added --tool generation, logging reports the fullpath which is so much more satisfying
                 tools.dev - FIX: reruns when not in --force mode had a logic bug which caused tests to be dumped in the wrong place
                 tools.dev - added --no-test and dev create supports a list of modules
    2024-11-22 - tools.dev - initial commit

# TODO: add git commit shit
# TODO: add life cycle shit
# TODO: track which files were generated by this tool and which arent
# TODO: create an auditor that can scan and see who is out of spec wrt relpath, description, tests, what files dont have a counterpart, which do not import correclty, everyone imports instantly, etc.
'''

# stdlib imports
from __future__ import absolute_import, print_function, division, with_statement  # , unicode_literals
import os
import sys
import re
import pydoc
import logging
from importlib import metadata
from dataclasses import dataclass, field
from typing import List, Optional, Dict, Type, Callable
from argparse import _SubParsersAction, ArgumentParser, ArgumentError, Namespace

# third party imports

# project imports
import chriscarl
from chriscarl.core.constants import REPO_DIRPATH, TESTS_DIRPATH
from chriscarl.core.lib.stdlib.logging import NAME_TO_LEVEL
from chriscarl.core.lib.stdlib.argparse import ArgparseNiceFormat
from chriscarl.core.lib.stdlib.os import abspath, chdir
from chriscarl.core.lib.stdlib.json import read_json
from chriscarl.core.lib.stdlib.io import read_text_file
from chriscarl.files import manifest
from chriscarl.tools.shed import dev

SCRIPT_RELPATH = 'chriscarl/tools/dev.py'
if not hasattr(sys, '_MEIPASS'):
    SCRIPT_FILEPATH = os.path.abspath(__file__)
else:
    SCRIPT_FILEPATH = os.path.abspath(os.path.join(sys._MEIPASS, SCRIPT_RELPATH))  # pylint: disable=no-member
SCRIPT_DIRPATH = os.path.dirname(SCRIPT_FILEPATH)
SCRIPT_NAME = os.path.splitext(os.path.basename(__file__))[0]
THIS_MODULE = sys.modules[__name__]
LOGGER = logging.getLogger(__name__)
LOGGER.addHandler(logging.NullHandler())

# argument defaults
DEFAULT_ROOT_LIB = chriscarl.__name__
DEFAULT_METADATA = metadata.metadata(DEFAULT_ROOT_LIB)
DEFAULT_AUTHOR = DEFAULT_METADATA.json['author']
DEFAULT_EMAIL = DEFAULT_METADATA.json['author_email']
DEFAULT_TESTS_DIRNAME = os.path.basename(TESTS_DIRPATH)
DEFAULT_BANNED_WORDS_FILEPATH = 'ignoreme/_banned'
DEFAULT_THRESHOLD = 0.83  # 85 is better but interpolated shadow modules from templates get 83% testable


@dataclass
class Mode:
    '''
    Generic mode class, its got what everyone has in common.
    '''
    mode: str
    cwd: str
    module: str
    author: str
    email: str
    log_level: str

    @classmethod
    def main(cls):
        parser = cls.argparser()
        mode = cls.from_parser(parser)
        logging.basicConfig(format='%(asctime)s - %(levelname)10s - %(filename)s - %(funcName)s - %(message)s', level=mode.log_level)
        sys.exit(mode.run())

    @staticmethod
    def add_common_arguments(parser, log_levels=None):
        # type: (ArgumentParser, Optional[List[str]]) -> ArgumentParser
        log_levels = log_levels or list(NAME_TO_LEVEL)
        parser.add_argument('--cwd', type=str, default=os.getcwd(), help='cd to this directory')
        parser.add_argument('--module', type=str, default=DEFAULT_ROOT_LIB, help='change the default lib? all modes act on this "root".')
        parser.add_argument('--author', type=str, default=DEFAULT_AUTHOR, help='author first last no space')
        parser.add_argument('--email', type=str, default=DEFAULT_EMAIL, help='author email')
        parser.add_argument('--log-level', type=str, default='INFO', choices=log_levels, help='log level?')
        return parser

    @classmethod
    def from_parser(cls, parser):
        # type: (ArgumentParser) -> Mode
        ns = parser.parse_args()
        return cls(**vars(ns))

    @classmethod
    def argparser(cls, subparser_root=None):
        # type: (Optional[_SubParsersAction[ArgumentParser]]) -> ArgumentParser
        if not subparser_root:
            mode = ArgumentParser(prog=SCRIPT_NAME, description=__doc__, formatter_class=ArgparseNiceFormat)
        else:
            mode = subparser_root.add_parser(cls.__name__.lower(), description=cls.__doc__, formatter_class=ArgparseNiceFormat)
        return mode

    def run(self):
        # type: () -> int
        LOGGER.info('%s running!', self.__class__.__name__)
        raise NotImplementedError()


@dataclass
class Create(Mode):
    '''
    Create is one of the CRUD modes allows you to "create" new modules.
    Based on predefined templates, it will create directories, __init__'s, module file, and test cases for you.

    Examples:
        - dev create lib.whatever
            # creates the following directory structure:
                - src/chriscarl/__init__.py
                - src/chriscarl/lib/__init__.py
                - src/chriscarl/lib/whatever.py
                - tests/chriscarl/test_lib.py
                - tests/chriscarl/lib/test_whatever.py
        - dev create lib
            # given you ran the above already which assumes certain things, creates the following directory structure:
                - SKIP: src/chriscarl/__init__.py
                - SKIP: src/chriscarl/lib/__init__.py
                - SKIP: src/chriscarl/lib/whatever.py
                - SKIP: tests/chriscarl/lib/test_whatever.py
        - dev create tools.fib --tool
            # generate a tool with the following files
                - SKIP: src/chriscarl/__init__.py
                - src/chriscarl/tools/__init__.py
                - src/chriscarl/tools.fib.py
                - tests/chriscarl/test_tools.py
                - tests/chriscarl/tools/test_fib.py
    '''
    modules: List[str] = field(default_factory=lambda: [])
    tests_dirname: str = DEFAULT_TESTS_DIRNAME
    force: bool = False
    tool: bool = False
    no_test: bool = False
    no_module: bool = False

    @classmethod
    def argparser(cls, subparser_root=None):
        # type: (Optional[_SubParsersAction[ArgumentParser]]) -> ArgumentParser
        mode = super().argparser(subparser_root=subparser_root)

        mode.add_argument('modules', type=str, nargs='+', default=[], help='space-separated, dot-separated module names, ex) "core.lib.stdlib.os" "core.lib.stdlib.sys"')
        mode.add_argument('--tests-dirname', type=str, default=DEFAULT_TESTS_DIRNAME, help='where should the tests go? core.lib will get a tests/module/core/test_lib.py')
        mode.add_argument('--force', '-f', action='store_true', help='overwrite file if exists?')
        mode.add_argument('--tool', '-t', action='store_true', help='make a tool out of this rather than a module (it still gets tests)')
        mode.add_argument('--no-test', '-n', action='store_true', help='do not generate the test')
        mode.add_argument('--no-module', action='store_true', help='do not generate the modules')
        Mode.add_common_arguments(mode)

        return mode

    def run(self):
        # type: () -> int
        created_type_module_filepaths = dev.create_modules_and_tests(
            self.module,
            self.modules,
            descriptions=read_json(manifest.FILEPATH_DEFAULT_DESCRIPTIONS_JSON),
            cwd=self.cwd,
            author=self.author,
            email=self.email,
            tests_dirname=self.tests_dirname,
            force=self.force,
            tool=self.tool,
            no_test=self.no_test,
            no_module=self.no_module,
            launch=True,
        )
        return len(created_type_module_filepaths) > 0


@dataclass
class Read(Mode):
    pass


@dataclass
class Update(Mode):
    pass


@dataclass
class Delete(Mode):
    pass


@dataclass
class Run(Mode):
    '''
    Run is an expansion on CRUD, since CRUD is state-less, "Run" adds state.
    Basically "run" any number of functions arbitrarily.

    Examples:
        - dev run --funcs "files._self_modify" "files._self_verify"
            # runs the following code in the default root module
                - chriscarl.files._self_modify()
                - chriscarl.files._self_verify()
        - dev run --funcs "vars" "locals" "globals" --module "builtins"
            # runs the following code from a different module
                - builtins.vars()
                - builtins.locals()
                - builtins.globals()
    '''
    print_help: bool
    funcs: List[str] = field(default_factory=lambda: [])

    @classmethod
    def argparser(cls, subparser_root=None):
        # type: (Optional[_SubParsersAction[ArgumentParser]]) -> ArgumentParser
        mode = super().argparser(subparser_root=subparser_root)

        mode.add_argument('funcs', type=str, nargs='+', default=[], help='module.func_name where full will be <--module>.module.func_name, provide multiple to run in series')
        mode.add_argument('--print-help', action='store_true', help='print the help of those funcs rather than execute them')
        Mode.add_common_arguments(mode)

        return mode

    def run(self):
        # type: () -> int
        return dev.run_functions_by_dot_path(self.module, self.funcs, print_help=self.print_help, log_level=self.log_level)


@dataclass
class Audit(Mode):
    '''
    Audit is the way i literally audit my own code from an infrastructure perspective. it's a poor-mans' linter so to speak. It is an expansion on CRUD, since CRUD is state-less, "Audit" adds state.
    Things like relpath compliance, word replacing, swear jar, self-modification, etc.

    Examples:
        - dev audit relpath
        - dev audit manifest-modify
    '''
    func: Callable
    dirpath: str
    dry: bool
    no_modify: bool
    no_verify: bool
    included_dirs: List[str] = field(default_factory=lambda: ['src/', 'tests'])
    tests_dirname: str = DEFAULT_TESTS_DIRNAME
    words_filepath: str = DEFAULT_BANNED_WORDS_FILEPATH
    words_additional: List[str] = field(default_factory=lambda: [])
    threshold: float = DEFAULT_THRESHOLD

    @classmethod
    def argparser(cls, subparser_root=None):
        # type: (Optional[_SubParsersAction[ArgumentParser]]) -> ArgumentParser
        mode = super().argparser(subparser_root=subparser_root)

        example_audit_func = 'tdd'
        funcs = mode.add_subparsers(
            help='which func do you want? run "{} {} {} -h" to get help on the {!r} func'.format(SCRIPT_NAME, cls.__name__.lower(), example_audit_func, example_audit_func)
        )

        manifest = funcs.add_parser('manifest', usage=pydoc.render_doc(dev.audit_manifest))
        manifest.set_defaults(func=dev.audit_manifest)
        Audit.add_common_arguments(manifest)

        relpath = funcs.add_parser('relpath', usage=pydoc.render_doc(dev.audit_relpath))
        relpath.set_defaults(func=dev.audit_relpath)
        Audit.add_common_arguments(relpath)

        tdd = funcs.add_parser('tdd', usage=pydoc.render_doc(dev.audit_tdd))
        tdd.set_defaults(func=dev.audit_tdd)
        Audit.add_common_arguments(tdd)

        banned = funcs.add_parser('banned', usage=pydoc.render_doc(dev.audit_banned))
        banned.set_defaults(func=dev.audit_banned)
        Audit.add_common_arguments(banned)

        stubs = funcs.add_parser('stubs', usage=pydoc.render_doc(dev.audit_stubs))
        stubs.set_defaults(func=dev.audit_stubs)
        Audit.add_common_arguments(stubs)

        clean = funcs.add_parser('clean', usage=pydoc.render_doc(dev.audit_clean))
        clean.set_defaults(func=dev.audit_clean)
        Audit.add_common_arguments(clean)

        cov = funcs.add_parser('cov', usage=pydoc.render_doc(dev.audit_cov))
        cov.set_defaults(func=dev.audit_cov)
        Audit.add_common_arguments(cov)

        return mode

    @staticmethod
    def add_common_arguments(parser):
        Mode.add_common_arguments(parser)
        parser.add_argument('--dirpath', type=str, default=REPO_DIRPATH, help='where do we start crawling?')
        parser.add_argument('--included_dirs', type=str, nargs='+', default=['src/', 'tests/'], help='any directories that you do care about, and run them relatively to dirpath?')
        parser.add_argument('--no-modify', action='store_true', help='do not modify?')
        parser.add_argument('--no-verify', action='store_true', help='do not verify?')
        parser.add_argument('--dry', action='store_true', help='do not write?')
        parser.add_argument('--tests-dirname', type=str, default=DEFAULT_TESTS_DIRNAME, help='name of the tests folder?')
        parser.add_argument('--words-filepath', type=str, default=DEFAULT_BANNED_WORDS_FILEPATH, help='filepath with a bunch of words you want banned?')
        parser.add_argument('--words-additional', type=str, nargs='+', default=[], help='add some other words in addition to the filepath or if the file doesnt exist?')
        parser.add_argument('--threshold', type=float, default=DEFAULT_THRESHOLD, help='any file that falls below this threshold is called out')

    def run(self):
        # type: () -> int
        LOGGER.info('starting %r', self.func.__name__)
        if self.func is dev.audit_manifest:
            return dev.audit_manifest(no_modify=self.no_modify, no_verify=self.no_verify)
        elif self.func is dev.audit_relpath:
            return dev.audit_relpath(dirpath=self.dirpath, included_dirs=self.included_dirs, dry=self.dry)
        elif self.func is dev.audit_tdd:
            return dev.audit_tdd(
                dirpath=self.dirpath,
                module_name=self.module,
                tests_dirname=self.tests_dirname,
                dry=self.dry,
                descriptions=read_json(manifest.FILEPATH_DEFAULT_DESCRIPTIONS_JSON),
                cwd=self.cwd,
                author=self.author,
                email=self.email,
                force=False,
                tool=False,
                no_test=False,
                no_module=True,
            )
        elif self.func is dev.audit_banned:
            words = []
            if os.path.isfile(self.words_filepath):
                words_content = read_text_file(self.words_filepath)
                words.extend([ele.strip() for ele in re.split(r'\s+', words_content) if ele.strip()])
            words.extend(self.words_additional)
            findings = dev.audit_banned(self.cwd, words, include=self.included_dirs)
            return sum(len(v) for v in findings.values())
        elif self.func is dev.audit_stubs:
            return dev.audit_stubs(self.dirpath, module_name=self.module)
        elif self.func is dev.audit_clean:
            return dev.audit_clean(dirpath=self.cwd)
        elif self.func is dev.audit_cov:
            return dev.audit_cov(dirpath=self.dirpath, module=self.module, tests_dirname=self.tests_dirname, threshold=self.threshold)
        else:
            return self.func()


MODE_MAP: Dict[str, Type[Mode]] = {
    'create': Create,
    'read': Read,
    'update': Update,
    'delete': Delete,
    'run': Run,
    'audit': Audit,
}


def main():
    # type: () -> int
    try:
        parser = ArgumentParser(prog=SCRIPT_NAME, description=__doc__, formatter_class=ArgparseNiceFormat)

        example_mode = list(MODE_MAP)[0]
        modes = parser.add_subparsers(help='which mode do you want? run "{} {} -h" to get help on the {!r} mode'.format(SCRIPT_NAME, example_mode, example_mode))

        for mode_name, Class in MODE_MAP.items():
            mode_parser = Class.argparser(subparser_root=modes)  # type: ignore
            mode_parser.set_defaults(mode=mode_name)
        subparser = [action for action in parser._actions if isinstance(action, _SubParsersAction)][0]
        ns = parser.parse_args()
    except ArgumentError as ae:
        print('ERROR:', ae, file=sys.stderr)
        sys.exit(1)

    if not hasattr(ns, 'mode'):
        raise ArgumentError(subparser, 'you have to provide an mode')

    Class = MODE_MAP[ns.mode]
    mode = Class.from_parser(parser)

    logging.basicConfig(format='%(asctime)s - %(levelname)10s - %(filename)s - %(funcName)s - %(message)s', level=mode.log_level)
    LOGGER.debug(vars(mode))

    with chdir(mode.cwd):
        return mode.run()


if __name__ == '__main__':
    sys.exit(main())
